export interface Question {
    id: string;
    topicId: string;
    question: string;
    options: string[];
    correctAnswer: number;
    explanation: string;
}

export const questions: Question[] = [
    // ========== ARRAYS ==========
    {
        id: 'arr-1',
        topicId: 'arrays',
        question: 'What is the time complexity of accessing an element in an array by index?',
        options: ['O(1)', 'O(n)', 'O(log n)', 'O(n²)'],
        correctAnswer: 0,
        explanation: 'Array elements are stored contiguously in memory, so accessing by index is a direct memory offset calculation — O(1).',
    },
    {
        id: 'arr-2',
        topicId: 'arrays',
        question: 'Which algorithm is most efficient for finding a target in a sorted array?',
        options: ['Linear Search', 'Binary Search', 'Jump Search', 'Interpolation Search'],
        correctAnswer: 1,
        explanation: 'Binary Search runs in O(log n) by repeatedly halving the search space. It is the go-to for sorted arrays.',
    },
    {
        id: 'arr-3',
        topicId: 'arrays',
        question: 'What does the Kadane\'s algorithm solve?',
        options: ['Sorting an array', 'Finding the maximum subarray sum', 'Reversing an array', 'Finding duplicates'],
        correctAnswer: 1,
        explanation: 'Kadane\'s algorithm finds the contiguous subarray with the largest sum in O(n) time.',
    },
    {
        id: 'arr-4',
        topicId: 'arrays',
        question: 'What is the worst-case time complexity of inserting an element at the beginning of an array?',
        options: ['O(1)', 'O(log n)', 'O(n)', 'O(n log n)'],
        correctAnswer: 2,
        explanation: 'Inserting at the beginning requires shifting all existing elements one position to the right, which takes O(n).',
    },
    {
        id: 'arr-5',
        topicId: 'arrays',
        question: 'In the two-pointer technique, what is the typical starting configuration for a sorted array?',
        options: ['Both at the start', 'Both at the end', 'One at each end', 'One at the middle, one at the end'],
        correctAnswer: 2,
        explanation: 'The classic two-pointer approach places one pointer at the start and one at the end, moving them inward based on conditions.',
    },
    {
        id: 'arr-6',
        topicId: 'arrays',
        question: 'What is the time complexity of the Dutch National Flag algorithm?',
        options: ['O(n log n)', 'O(n)', 'O(n²)', 'O(1)'],
        correctAnswer: 1,
        explanation: 'The Dutch National Flag algorithm sorts an array of 0s, 1s, and 2s in a single pass — O(n) time, O(1) space.',
    },
    {
        id: 'arr-7',
        topicId: 'arrays',
        question: 'Which sorting algorithm has the best average-case time complexity?',
        options: ['Bubble Sort — O(n²)', 'Merge Sort — O(n log n)', 'Selection Sort — O(n²)', 'Insertion Sort — O(n²)'],
        correctAnswer: 1,
        explanation: 'Merge Sort consistently runs in O(n log n) in all cases — best, average, and worst.',
    },
    {
        id: 'arr-8',
        topicId: 'arrays',
        question: 'What does the sliding window technique help optimize?',
        options: ['Sorting operations', 'Subarray / substring problems', 'Graph traversals', 'Tree rotations'],
        correctAnswer: 1,
        explanation: 'Sliding window efficiently computes properties of contiguous subarrays/substrings by maintaining a window that slides through the array.',
    },
    {
        id: 'arr-9',
        topicId: 'arrays',
        question: 'What is the space complexity of Merge Sort?',
        options: ['O(1)', 'O(log n)', 'O(n)', 'O(n log n)'],
        correctAnswer: 2,
        explanation: 'Merge Sort requires O(n) extra space for the temporary arrays used during merging.',
    },
    {
        id: 'arr-10',
        topicId: 'arrays',
        question: 'How do you find the majority element (appears > n/2 times) in O(n) time?',
        options: ['Sort and pick middle', 'Boyer-Moore Voting Algorithm', 'Use a hash map', 'All of these work'],
        correctAnswer: 3,
        explanation: 'All three approaches work, but Boyer-Moore is the most space-efficient at O(1) space. Sorting is O(n log n) time though.',
    },
    {
        id: 'arr-11',
        topicId: 'arrays',
        question: 'What is a prefix sum array used for?',
        options: ['Sorting elements', 'Answering range sum queries in O(1)', 'Finding duplicates', 'Reversing subarrays'],
        correctAnswer: 1,
        explanation: 'A prefix sum array preprocesses cumulative sums so that any range sum query can be answered in O(1) after O(n) preprocessing.',
    },
    {
        id: 'arr-12',
        topicId: 'arrays',
        question: 'What is the worst-case time complexity of QuickSort?',
        options: ['O(n)', 'O(n log n)', 'O(n²)', 'O(log n)'],
        correctAnswer: 2,
        explanation: 'QuickSort degrades to O(n²) when the pivot is always the smallest or largest element (e.g., already sorted array with bad pivot choice).',
    },
    {
        id: 'arr-13',
        topicId: 'arrays',
        question: 'What technique is used to rotate an array by k positions in O(n) time and O(1) space?',
        options: ['Using a temp array', 'Reversal algorithm', 'Bubble rotation', 'Cyclic replacement only'],
        correctAnswer: 1,
        explanation: 'The reversal algorithm reverses parts of the array (first k, then rest, then whole) to achieve rotation in-place.',
    },
    {
        id: 'arr-14',
        topicId: 'arrays',
        question: 'In a sorted array with duplicates, how do you find the first occurrence of a target?',
        options: ['Linear scan from start', 'Modified binary search (leftmost)', 'Standard binary search', 'Hash map lookup'],
        correctAnswer: 1,
        explanation: 'A modified binary search that continues searching left even after finding a match gives the first occurrence in O(log n).',
    },
    {
        id: 'arr-15',
        topicId: 'arrays',
        question: 'What is the Trapping Rain Water problem solved with?',
        options: ['Greedy only', 'Two pointers or precomputed max arrays', 'Recursion', 'BFS'],
        correctAnswer: 1,
        explanation: 'Trapping rain water can be solved with two pointers in O(n) time O(1) space, or with precomputed left-max and right-max arrays.',
    },

    // ========== STRINGS ==========
    {
        id: 'str-1',
        topicId: 'strings',
        question: 'What is the time complexity of the KMP string matching algorithm?',
        options: ['O(n × m)', 'O(n + m)', 'O(n²)', 'O(n log m)'],
        correctAnswer: 1,
        explanation: 'KMP preprocesses the pattern in O(m) and then matches in O(n), giving O(n + m) total.',
    },
    {
        id: 'str-2',
        topicId: 'strings',
        question: 'Which data structure is commonly used to check if a string is a palindrome efficiently?',
        options: ['Stack', 'Queue', 'Two pointers', 'Hash Map'],
        correctAnswer: 2,
        explanation: 'Two pointers (one from each end) can verify a palindrome in O(n) time with O(1) space.',
    },
    {
        id: 'str-3',
        topicId: 'strings',
        question: 'What does an anagram of a string mean?',
        options: ['Same characters in sorted order', 'Same characters rearranged', 'A substring of the original', 'A reversed string'],
        correctAnswer: 1,
        explanation: 'An anagram is a rearrangement of all characters of a string to form another valid arrangement.',
    },
    {
        id: 'str-4',
        topicId: 'strings',
        question: 'What is the space complexity of storing all substrings of a string of length n?',
        options: ['O(n)', 'O(n²)', 'O(n³)', 'O(2ⁿ)'],
        correctAnswer: 2,
        explanation: 'There are O(n²) substrings, and each can be up to O(n) in length, giving O(n³) total space.',
    },
    {
        id: 'str-5',
        topicId: 'strings',
        question: 'Which technique is used in the Rabin-Karp algorithm for pattern matching?',
        options: ['Dynamic Programming', 'Rolling Hash', 'Divide and Conquer', 'Greedy'],
        correctAnswer: 1,
        explanation: 'Rabin-Karp uses a rolling hash to efficiently compare the hash of the pattern with substrings of the text.',
    },

    // ========== LINKED LIST ==========
    {
        id: 'll-1',
        topicId: 'linked-list',
        question: 'What is the time complexity of inserting a node at the head of a singly linked list?',
        options: ['O(1)', 'O(n)', 'O(log n)', 'O(n²)'],
        correctAnswer: 0,
        explanation: 'Inserting at the head only requires updating the head pointer, which is O(1).',
    },
    {
        id: 'll-2',
        topicId: 'linked-list',
        question: 'How do you detect a cycle in a linked list efficiently?',
        options: ['Use a hash set', 'Floyd\'s Tortoise and Hare algorithm', 'Reverse the list', 'Both A and B work'],
        correctAnswer: 3,
        explanation: 'A hash set works in O(n) space. Floyd\'s algorithm uses two pointers (slow/fast) with O(1) space. Both detect cycles.',
    },
    {
        id: 'll-3',
        topicId: 'linked-list',
        question: 'What is the main advantage of a doubly linked list over a singly linked list?',
        options: ['Less memory usage', 'Faster traversal', 'Bidirectional traversal', 'Better cache locality'],
        correctAnswer: 2,
        explanation: 'A doubly linked list has both next and prev pointers, allowing traversal in both directions.',
    },
    {
        id: 'll-4',
        topicId: 'linked-list',
        question: 'What is the time complexity of finding the middle element of a linked list using the slow-fast pointer technique?',
        options: ['O(1)', 'O(n)', 'O(n/2)', 'O(log n)'],
        correctAnswer: 1,
        explanation: 'The fast pointer moves 2x speed. When it reaches the end, the slow pointer is at the middle. This traverses O(n) nodes.',
    },
    {
        id: 'll-5',
        topicId: 'linked-list',
        question: 'Which operation is NOT O(1) in a singly linked list with only a head pointer?',
        options: ['Insert at head', 'Delete from head', 'Insert at tail', 'Access head element'],
        correctAnswer: 2,
        explanation: 'Without a tail pointer, inserting at the tail requires traversing the entire list to find the last node — O(n).',
    },

    // ========== STACK ==========
    {
        id: 'stk-1',
        topicId: 'stack',
        question: 'Which principle does a stack follow?',
        options: ['FIFO', 'LIFO', 'Priority-based', 'Random access'],
        correctAnswer: 1,
        explanation: 'A stack follows Last In, First Out (LIFO) — the most recently added element is removed first.',
    },
    {
        id: 'stk-2',
        topicId: 'stack',
        question: 'What is a common application of stacks in compilers?',
        options: ['Memory allocation', 'Balanced parentheses checking', 'Sorting', 'Graph traversal'],
        correctAnswer: 1,
        explanation: 'Stacks are used to check if parentheses, brackets, and braces are properly balanced in expressions.',
    },
    {
        id: 'stk-3',
        topicId: 'stack',
        question: 'What is the time complexity of push and pop operations on a stack?',
        options: ['O(n)', 'O(log n)', 'O(1)', 'O(n²)'],
        correctAnswer: 2,
        explanation: 'Both push and pop operate on the top of the stack, making them O(1) operations.',
    },
    {
        id: 'stk-4',
        topicId: 'stack',
        question: 'Which traversal of a binary tree can be implemented iteratively using a stack?',
        options: ['Level-order', 'Inorder', 'BFS', 'All of the above'],
        correctAnswer: 1,
        explanation: 'Inorder (and preorder/postorder) tree traversals can be done iteratively using an explicit stack.',
    },
    {
        id: 'stk-5',
        topicId: 'stack',
        question: 'What does the "Next Greater Element" problem use?',
        options: ['Queue', 'Monotonic Stack', 'Binary Search', 'Heap'],
        correctAnswer: 1,
        explanation: 'A monotonic stack efficiently finds the next greater element for each element in O(n) time.',
    },

    // ========== QUEUE ==========
    {
        id: 'que-1',
        topicId: 'queue',
        question: 'Which principle does a queue follow?',
        options: ['LIFO', 'FIFO', 'Priority-based', 'Random access'],
        correctAnswer: 1,
        explanation: 'A queue follows First In, First Out (FIFO) — the element added first is removed first.',
    },
    {
        id: 'que-2',
        topicId: 'queue',
        question: 'Which data structure is used for BFS (Breadth-First Search)?',
        options: ['Stack', 'Queue', 'Heap', 'Linked List'],
        correctAnswer: 1,
        explanation: 'BFS explores nodes level by level, which naturally maps to a queue (FIFO) structure.',
    },
    {
        id: 'que-3',
        topicId: 'queue',
        question: 'What is a circular queue?',
        options: ['A queue with no size limit', 'A queue where the last position connects to the first', 'A double-ended queue', 'A priority queue'],
        correctAnswer: 1,
        explanation: 'A circular queue wraps around, connecting the last position back to the first to efficiently reuse space.',
    },
    {
        id: 'que-4',
        topicId: 'queue',
        question: 'What is a deque?',
        options: ['A queue that can only dequeue', 'A double-ended queue', 'A queue with two priorities', 'A queue implemented with two stacks'],
        correctAnswer: 1,
        explanation: 'A deque (double-ended queue) allows insertion and deletion from both the front and the rear.',
    },
    {
        id: 'que-5',
        topicId: 'queue',
        question: 'How can you implement a queue using two stacks?',
        options: ['Push to stack1, pop from stack2 (transfer if empty)', 'Use both stacks alternately', 'It is not possible', 'Push to both stacks simultaneously'],
        correctAnswer: 0,
        explanation: 'Push elements onto stack1. For dequeue, if stack2 is empty, transfer all from stack1 to stack2, then pop from stack2.',
    },

    // ========== RECURSION ==========
    {
        id: 'rec-1',
        topicId: 'recursion',
        question: 'What is the base case in recursion?',
        options: ['The recursive call', 'The condition that stops recursion', 'The first function call', 'The return type'],
        correctAnswer: 1,
        explanation: 'The base case is the condition that terminates the recursion, preventing infinite calls.',
    },
    {
        id: 'rec-2',
        topicId: 'recursion',
        question: 'What is tail recursion?',
        options: ['Recursion with two base cases', 'Recursion where the recursive call is the last operation', 'Recursion that uses a loop', 'Recursion with multiple recursive calls'],
        correctAnswer: 1,
        explanation: 'Tail recursion means the recursive call is the very last operation, allowing compilers to optimize it into a loop.',
    },
    {
        id: 'rec-3',
        topicId: 'recursion',
        question: 'What is the time complexity of a naive recursive Fibonacci implementation?',
        options: ['O(n)', 'O(n²)', 'O(2ⁿ)', 'O(log n)'],
        correctAnswer: 2,
        explanation: 'Each call branches into two recursive calls, leading to an exponential O(2ⁿ) time complexity.',
    },
    {
        id: 'rec-4',
        topicId: 'recursion',
        question: 'What problem does the "Tower of Hanoi" demonstrate?',
        options: ['Sorting', 'Recursion with divide and conquer', 'Graph traversal', 'Dynamic programming'],
        correctAnswer: 1,
        explanation: 'Tower of Hanoi is a classic recursion problem that breaks down into smaller subproblems (move n-1 disks, move 1 disk, move n-1 disks).',
    },
    {
        id: 'rec-5',
        topicId: 'recursion',
        question: 'What happens if a recursive function has no base case?',
        options: ['It returns 0', 'It runs forever (stack overflow)', 'It automatically stops after 1000 calls', 'It returns null'],
        correctAnswer: 1,
        explanation: 'Without a base case, the function calls itself indefinitely until the call stack overflows, causing a crash.',
    },

    // ========== TREES ==========
    {
        id: 'tree-1',
        topicId: 'trees',
        question: 'What is the maximum number of nodes at level L in a binary tree?',
        options: ['L', '2L', '2^L', '2^(L+1)'],
        correctAnswer: 2,
        explanation: 'At level L (starting from 0), a binary tree can have at most 2^L nodes.',
    },
    {
        id: 'tree-2',
        topicId: 'trees',
        question: 'What is the time complexity of searching in a balanced Binary Search Tree?',
        options: ['O(1)', 'O(n)', 'O(log n)', 'O(n log n)'],
        correctAnswer: 2,
        explanation: 'A balanced BST halves the search space at each step, giving O(log n) search time.',
    },
    {
        id: 'tree-3',
        topicId: 'trees',
        question: 'Which traversal gives nodes of a BST in sorted order?',
        options: ['Preorder', 'Inorder', 'Postorder', 'Level-order'],
        correctAnswer: 1,
        explanation: 'Inorder traversal (Left → Root → Right) of a BST visits nodes in ascending sorted order.',
    },
    {
        id: 'tree-4',
        topicId: 'trees',
        question: 'What is the height of a complete binary tree with n nodes?',
        options: ['O(n)', 'O(log n)', 'O(√n)', 'O(n²)'],
        correctAnswer: 1,
        explanation: 'A complete binary tree is nearly balanced, so its height is O(log n).',
    },
    {
        id: 'tree-5',
        topicId: 'trees',
        question: 'What is the Lowest Common Ancestor (LCA) of two nodes?',
        options: ['The root node', 'The deepest node that is an ancestor of both', 'The parent of both nodes', 'The node with the smallest value'],
        correctAnswer: 1,
        explanation: 'The LCA is the deepest (lowest) node in the tree that has both given nodes as descendants.',
    },

    // ========== GRAPHS ==========
    {
        id: 'graph-1',
        topicId: 'graphs',
        question: 'What is the time complexity of BFS on a graph with V vertices and E edges?',
        options: ['O(V)', 'O(E)', 'O(V + E)', 'O(V × E)'],
        correctAnswer: 2,
        explanation: 'BFS visits each vertex once and traverses each edge once, giving O(V + E).',
    },
    {
        id: 'graph-2',
        topicId: 'graphs',
        question: 'Which algorithm finds the shortest path in a weighted graph with non-negative edges?',
        options: ['BFS', 'DFS', 'Dijkstra\'s Algorithm', 'Bellman-Ford Algorithm'],
        correctAnswer: 2,
        explanation: 'Dijkstra\'s algorithm uses a priority queue to greedily find shortest paths from a source, requiring non-negative edge weights.',
    },
    {
        id: 'graph-3',
        topicId: 'graphs',
        question: 'How do you detect a cycle in a directed graph?',
        options: ['BFS only', 'DFS with back edge detection', 'Topological sort', 'Both B and C'],
        correctAnswer: 3,
        explanation: 'A cycle exists if DFS finds a back edge, or if topological sort fails (not all vertices are processed).',
    },
    {
        id: 'graph-4',
        topicId: 'graphs',
        question: 'What is a topological sort used for?',
        options: ['Sorting edges by weight', 'Ordering tasks with dependencies', 'Finding shortest paths', 'Detecting bridges'],
        correctAnswer: 1,
        explanation: 'Topological sort orders vertices of a DAG so that for every directed edge u→v, u comes before v — ideal for dependency resolution.',
    },
    {
        id: 'graph-5',
        topicId: 'graphs',
        question: 'What does Kruskal\'s algorithm find?',
        options: ['Shortest path', 'Minimum Spanning Tree', 'Maximum flow', 'Strongly connected components'],
        correctAnswer: 1,
        explanation: 'Kruskal\'s algorithm greedily picks the smallest edges (without forming a cycle) to build a Minimum Spanning Tree.',
    },

    // ========== DYNAMIC PROGRAMMING ==========
    {
        id: 'dp-1',
        topicId: 'dp',
        question: 'What are the two key properties of a problem that make it suitable for Dynamic Programming?',
        options: ['Sorting and searching', 'Optimal substructure and overlapping subproblems', 'Greedy choice and divide & conquer', 'Recursion and iteration'],
        correctAnswer: 1,
        explanation: 'DP requires optimal substructure (solution built from sub-solutions) and overlapping subproblems (same subproblems solved multiple times).',
    },
    {
        id: 'dp-2',
        topicId: 'dp',
        question: 'What is memoization?',
        options: ['Sorting results', 'Caching results of expensive function calls', 'A type of recursion', 'Storing data in a linked list'],
        correctAnswer: 1,
        explanation: 'Memoization stores the results of already-computed subproblems to avoid redundant calculations (top-down DP).',
    },
    {
        id: 'dp-3',
        topicId: 'dp',
        question: 'What is the time complexity of the 0/1 Knapsack problem using DP?',
        options: ['O(n)', 'O(n × W)', 'O(2ⁿ)', 'O(n²)'],
        correctAnswer: 1,
        explanation: 'The DP table is n items × W capacity, so filling it takes O(n × W) — pseudo-polynomial time.',
    },
    {
        id: 'dp-4',
        topicId: 'dp',
        question: 'What is the difference between top-down and bottom-up DP?',
        options: ['Top-down is faster', 'Top-down uses recursion + memoization, bottom-up uses iteration + tabulation', 'They are the same', 'Bottom-up is always better'],
        correctAnswer: 1,
        explanation: 'Top-down starts from the main problem and recurses down (with memoization). Bottom-up builds solutions iteratively from the smallest subproblems.',
    },
    {
        id: 'dp-5',
        topicId: 'dp',
        question: 'Which classic problem asks for the longest subsequence common to two sequences?',
        options: ['Longest Increasing Subsequence', 'Longest Common Subsequence', 'Edit Distance', 'Longest Palindromic Substring'],
        correctAnswer: 1,
        explanation: 'The Longest Common Subsequence (LCS) problem finds the longest subsequence present in both input sequences, solvable in O(n × m) with DP.',
    },
];
